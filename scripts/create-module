#!/usr/bin/env python3
"""
CLI script to create a new FastAPI module following the project structure.
Usage: python scripts/create-module
"""

import sys
from pathlib import Path
import re


def validate_feature_name(feature_name: str) -> bool:
    """Validate feature name format (lowercase, alphanumeric, underscores)"""
    return bool(re.match(r"^[a-z][a-z0-9_]*$", feature_name))


def create_directory_structure(base_path: Path, feature_name: str) -> Path:
    """Create the module directory structure"""
    module_path = base_path / "api_app" / "modules" / feature_name
    module_path.mkdir(parents=True, exist_ok=True)
    return module_path


def create_init_file(module_path: Path):
    """Create __init__.py file"""
    init_content = '"""Module initialization"""'
    (module_path / "__init__.py").write_text(init_content)


def create_schemas_file(module_path: Path, feature_name: str):
    """Create schemas.py file"""
    pascal_case = "".join(word.capitalize() for word in feature_name.split("_"))

    content = f'''"""
{pascal_case} module schemas (DTOs)
"""
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

from ...core.schemas import BaseSchema


class {pascal_case}Request(BaseModel):
    """Request schema for {feature_name} operations"""
    # TODO: Add your request fields here
    pass


class {pascal_case}Response(BaseSchema):
    """Response schema for {feature_name} operations"""
    id: str
    # TODO: Add your response fields here

    @classmethod
    def from_entity(cls, entity) -> "{pascal_case}Response":
        """Convert entity to response schema"""
        return cls(
            id=str(entity.id),
            # TODO: Map entity fields to response fields
        )
'''

    (module_path / "schemas.py").write_text(content)


def create_repository_file(module_path: Path, feature_name: str):
    """Create repository.py file"""
    pascal_case = "".join(word.capitalize() for word in feature_name.split("_"))

    content = f'''"""
{pascal_case} repository for data access operations
"""
from typing import List, Optional

from ...core.base_repository import BaseRepository
from ...models.{feature_name}_model import {pascal_case}


class {pascal_case}Repository(BaseRepository[{pascal_case}]):
    """Repository for {pascal_case} data operations"""
    
    def __init__(self):
        super().__init__({pascal_case})

    # TODO: Add your custom repository methods here
    # Example:
    # async def find_by_custom_field(self, field_value: str) -> Optional[{pascal_case}]:
    #     """Find {feature_name} by custom field"""
    #     return await self.model.find_one({{"custom_field": field_value}})
'''

    (module_path / "repository.py").write_text(content)


def create_use_case_file(module_path: Path, feature_name: str):
    """Create use_case.py file"""
    pascal_case = "".join(word.capitalize() for word in feature_name.split("_"))

    content = f'''"""
{pascal_case} use case containing business logic
"""
from fastapi import Depends
from typing import List, Optional

from ...models.{feature_name}_model import {pascal_case}
from .repository import {pascal_case}Repository
from .schemas import {pascal_case}Request, {pascal_case}Response


class {pascal_case}UseCase:
    """Use case for {pascal_case} business operations"""
    
    def __init__(self, {feature_name}_repository: {pascal_case}Repository):
        self.{feature_name}_repository = {feature_name}_repository

    # TODO: Add your business logic methods here
    # Example:
    # async def process_{feature_name}(self, data: {pascal_case}Request) -> {pascal_case}Response:
    #     """Process {feature_name} business logic"""
    #     # 1. Validate business rules
    #     # 2. Process data
    #     # 3. Call repository
    #     # 4. Return result
    #     pass


# Dependency providers
async def get_{feature_name}_repository() -> {pascal_case}Repository:
    """Get {feature_name} repository instance"""
    return {pascal_case}Repository()


async def get_{feature_name}_use_case(
    repository: {pascal_case}Repository = Depends(get_{feature_name}_repository)
) -> {pascal_case}UseCase:
    """Get {feature_name} use case with injected dependencies"""
    return {pascal_case}UseCase({feature_name}_repository=repository)
'''

    (module_path / "use_case.py").write_text(content)


def create_router_file(module_path: Path, feature_name: str):
    """Create router.py file"""
    pascal_case = "".join(word.capitalize() for word in feature_name.split("_"))

    content = f'''"""
{pascal_case} API router with REST endpoints
"""
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List

from ...models.user_model import User
from .use_case import get_{feature_name}_use_case, {pascal_case}UseCase
from .schemas import {pascal_case}Request, {pascal_case}Response


router = APIRouter(prefix="/v1/{feature_name}", tags=["{pascal_case}"])

# TODO: Add your API endpoints here
# Example:
# @router.get("", response_model=List[{pascal_case}Response])
# async def list_{feature_name}(
#     {feature_name}_use_case: {pascal_case}UseCase = Depends(get_{feature_name}_use_case)
# ):
#     """List {feature_name} items"""
#     # Implement your logic here
#     pass
'''

    (module_path / "router.py").write_text(content)


def create_model_file(base_path: Path, feature_name: str):
    """Create model file"""
    pascal_case = "".join(word.capitalize() for word in feature_name.split("_"))
    models_path = base_path / "api_app" / "models"
    model_file = models_path / f"{feature_name}_model.py"

    content = f'''"""
{pascal_case} Beanie document model
"""
from beanie import Document
from pydantic import Field
from typing import Optional
from datetime import datetime, timezone


class {pascal_case}(Document):
    """
    {pascal_case} document model for MongoDB collection
    """
    # TODO: Add your model fields here
    # Example:
    # name: str = Field(..., min_length=1, max_length=100)
    # description: Optional[str] = Field(None, max_length=500)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: Optional[datetime] = None

    class Settings:
        name = "{feature_name}"  # Collection name in MongoDB
        # TODO: Add your indexes here
        # indexes = [
        #     "field_name",
        #     "created_at"
        # ]

    def __str__(self) -> str:
        return f"{pascal_case}(id={{self.id}})"
'''

    model_file.write_text(content)
    return model_file


def print_success_message(feature_name: str, module_path: Path, model_file: Path):
    """Print success message with next steps"""
    pascal_case = "".join(word.capitalize() for word in feature_name.split("_"))

    print(f"âœ… Successfully created '{feature_name}' module skeleton!")
    print(f"ğŸ“ Module path: {module_path}")
    print(f"ğŸ“„ Model file: {model_file}")
    print()
    print("ğŸ”§ Next steps:")
    print(
        f"1. Update api_app/infrastructure/database.py to include {pascal_case} model"
    )
    print("2. Customize the generated skeleton files according to your requirements:")
    print(f"   - Add model fields in {feature_name}_model.py")
    print("   - Add request/response schemas in schemas.py")
    print("   - Add repository methods in repository.py")
    print("   - Add business logic in use_case.py")
    print("   - Add API endpoints in router.py")
    print("3. The router will be auto-discovered when you add endpoints")
    print()
    print("ğŸ“ Generated skeleton files:")
    print(f"   - {module_path}/__init__.py")
    print(f"   - {module_path}/schemas.py (basic structure)")
    print(f"   - {module_path}/repository.py (basic structure)")
    print(f"   - {module_path}/use_case.py (basic structure)")
    print(f"   - {module_path}/router.py (basic structure)")
    print(f"   - {model_file} (basic structure)")
    print()
    print("ğŸ’¡ All files contain TODO comments to guide your implementation")


def print_help():
    """Print help message"""
    print("ğŸš€ FastAPI Module Generator")
    print("=" * 50)
    print()
    print("DESCRIPTION:")
    print(
        "    Create a new FastAPI module skeleton following Clean Architecture patterns"
    )
    print(
        "    Generates basic structure without CRUD implementation - ready for customization"
    )
    print()
    print("USAGE:")
    print("    python scripts/create-module")
    print("    ./scripts/create-module")
    print()
    print("OPTIONS:")
    print("    -h, --help    Show this help message")
    print()
    print("INTERACTIVE MODE:")
    print("    The script will prompt you to enter:")
    print("    - Feature name (e.g., 'products', 'orders', 'user_profiles')")
    print("    - Confirmation to create the module")
    print()
    print("GENERATED SKELETON FILES:")
    print("    api_app/modules/{feature}/")
    print("    â”œâ”€â”€ __init__.py")
    print("    â”œâ”€â”€ schemas.py      # Basic Pydantic schemas with TODOs")
    print("    â”œâ”€â”€ repository.py   # Basic repository structure with TODOs")
    print("    â”œâ”€â”€ use_case.py     # Basic use case structure with TODOs")
    print("    â””â”€â”€ router.py       # Basic router structure with TODOs")
    print("    api_app/models/{feature}_model.py  # Basic Beanie model with TODOs")
    print()
    print("REQUIREMENTS:")
    print("    - Run from project root directory")
    print("    - Directory must contain 'api_app' folder")
    print()
    print("NOTE:")
    print("    Generated files are skeleton templates with TODO comments.")
    print("    Customize them according to your specific requirements.")
    print()


def main():
    """Main CLI function"""
    # Check for help flag
    if len(sys.argv) > 1 and sys.argv[1] in ["--help", "-h", "help"]:
        print_help()
        sys.exit(0)

    print("ğŸš€ FastAPI Module Generator")
    print("=" * 50)

    # Get current directory
    current_dir = Path.cwd()

    # Check if we're in the right directory
    if not (current_dir / "api_app").exists():
        print("âŒ Error: This script must be run from the project root directory")
        print("   Make sure you're in the directory containing 'api_app' folder")
        sys.exit(1)

    # Get feature name from user
    while True:
        feature_name = (
            input(
                "\nğŸ“ Enter feature name (e.g., 'products', 'orders', 'user_profiles'): "
            )
            .strip()
            .lower()
        )

        if not feature_name:
            print("âŒ Feature name cannot be empty")
            continue

        if not validate_feature_name(feature_name):
            print(
                "âŒ Invalid feature name. Use lowercase letters, numbers, and underscores only."
            )
            print("   Examples: 'products', 'user_profiles', 'order_items'")
            continue

        # Check if module already exists
        module_path = current_dir / "api_app" / "modules" / feature_name
        if module_path.exists():
            print(f"âŒ Module '{feature_name}' already exists at {module_path}")
            continue

        break

    print(f"\nğŸ“‹ Creating module skeleton: {feature_name}")
    print(f"ğŸ“ Location: api_app/modules/{feature_name}")

    # Confirm creation
    confirm = (
        input(f"\nâ“ Create '{feature_name}' module skeleton? (y/N): ").strip().lower()
    )
    if confirm not in ["y", "yes"]:
        print("âŒ Module creation cancelled")
        sys.exit(0)

    try:
        # Create module structure
        print("\nğŸ”¨ Creating module skeleton structure...")
        module_path = create_directory_structure(current_dir, feature_name)

        # Create files
        print("ğŸ“ Creating __init__.py...")
        create_init_file(module_path)

        print("ğŸ“ Creating schemas.py skeleton...")
        create_schemas_file(module_path, feature_name)

        print("ğŸ“ Creating repository.py skeleton...")
        create_repository_file(module_path, feature_name)

        print("ğŸ“ Creating use_case.py skeleton...")
        create_use_case_file(module_path, feature_name)

        print("ğŸ“ Creating router.py skeleton...")
        create_router_file(module_path, feature_name)

        print("ğŸ“ Creating model skeleton...")
        model_file = create_model_file(current_dir, feature_name)

        # Success message
        print_success_message(feature_name, module_path, model_file)

    except Exception as e:
        print(f"âŒ Error creating module: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
